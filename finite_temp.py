# -*- coding: utf-8 -*-
"""Finite_temp.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1nMhg_I9Dfm4dMOtOz1Oc2_ZkQlnOV-Sx

# Initial stuff

## Imports and installations
"""

## install qiskit
#!pip install qiskit
#!pip install qiskit-aer
#!pip install scikit-rmt

import qiskit.quantum_info as qi
#from qiskit.extensions.quantum_initializer.initializer import initialize
from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister
# from qiskit import IBMQ, Aer, transpile, assemble, execute    # Old libraries for Aer, new below
from qiskit import IBMQ, transpile, assemble, execute
from qiskit.visualization import plot_histogram, plot_bloch_multivector, array_to_latex
from qiskit.extensions import Initialize, UnitaryGate
#from qiskit.ignis.verification import marginal_counts
from qiskit.quantum_info import random_statevector
from qiskit import extensions
from qiskit.quantum_info.operators.operator import Operator
from qiskit.circuit.add_control import add_control
from scipy.linalg import expm
from qiskit.quantum_info import Statevector
import shutil
import statistics
from qiskit_aer import Aer
from skrmt.ensemble import GaussianEnsemble

import numpy as np
import scipy as sp
from numpy.linalg import eig
import matplotlib.pyplot as plt
from skrmt.ensemble.gaussian_ensemble import GaussianEnsemble

from scipy.stats import unitary_group

# functions needed to run experiment
def get_H(n):
  """Sample H from the Gaussian unitary ensemble, GUE(N). N = 2**n, where n is
  the number of pairs shared by Alice and Bob (W in equation 4)."""
  # sampling a GUE (beta=2) matrix of size (2^n)x(2^n)
  H = GaussianEnsemble(beta=2, n=2**n).matrix
  #H = H/np.linalg.norm(H)
  return H

def partition_function(H, beta):
  eig_vals, eig_vecs = eig(H)
  exps = np.exp(-beta * eig_vals)
  return np.sum(exps)

def random_U(n):
  dim = 2 ** n
  H=np.random.rand(dim,dim)+1j*np.random.rand(dim,dim)
  H = H+H.conj().T
  return sp.linalg.expm(1j*H)

def prepare_tfd(n, H, beta):
  """Prepare thermofield double state for Hamiltonian H at inverse temperature
  beta."""
  eig_vals, eig_vecs_A = eig(H)
  # partition function
  exps = np.exp(-beta * eig_vals / 2)
  z = np.sum(exps**2)
  eig_vecs_B = np.conjugate(eig_vecs_A)
  tfd = 0
  for i in range(2**n):
    tfd += exps[i] * np.kron(eig_vecs_A[i], eig_vecs_B[i])
  tfd = tfd/np.sqrt(z)
  new_shape = (2*n)*[2]
  tfd = tfd.reshape(*new_shape)
  transposition = [i for i in range(n)] + [2*n-1-i for i in range(n)]
  tfd = tfd.transpose(transposition)
  tfd = tfd.reshape(2**(2*n))
  return tfd

def prepare_bell():
  """Bell state (|00> + |11>)/sqrt(2).
  """
  return np.array([1,0,0,1])/np.sqrt(2)

def prepare_init_state(n, H, beta):
  """Prepare initial state of the circuit (before the swap)."""
  bell = prepare_bell()
  tfd = prepare_tfd(n, H, beta)
  init_state = np.kron(bell, tfd)
  init_state = np.kron(init_state, bell)
  return init_state

def swap(state):
  """Swap half of Alice and Bob's Bell pairs in the TFD."""
  N = len(state)
  # reshaped psi_i -> psi_{i0, i1, i2, I, i_4, i_5, i_6}
  state = state.reshape(2,2,2,int(N/64),2,2,2)
  # swap i1 with i2 and i_4 with i_5
  state = state.transpose((0,2,1,3,5,4,6))
  # reshaped psi_{i0, i2, i1, I, i_5, i_4, i_6} -> psi_i
  return state.reshape(N)

def apply_unitaries(state, n, H, t):
  """Apply unitary evolution operators.
  """
  U = sp.linalg.expm(1j*t*H)
  U_conj =  np.conj(U)
  new_shape = (2*n)*[2]
  U_conj = U_conj.reshape(*new_shape)
  transposition = [n-1-i for i in range(n)] + [2*n-1-i for i in range(n)]
  U_conj = U_conj.transpose(transposition)
  U_conj = U_conj.reshape(2**n, 2**n)
  UxU = np.kron(np.eye(4), U)
  UxU = np.kron(UxU, U_conj)
  UxU = np.kron(UxU, np.eye(4))
  return UxU @ state

def bell_proj():
  """Generate projector on Bell state (|00> + |11>)/sqrt(2)."""
  bell = prepare_bell()
  return np.outer(bell, bell)

def apply_proj(state, n):
  """Apply projector on Bell state on the central qubits."""
  proj = bell_proj()
  size_around = 4*2**(n-1)
  op = np.kron(np.eye(size_around), proj)
  op = np.kron(op, np.eye(size_around))
  return op @ state

def bell_meas(state, n):
  """Project remaining half of Bell pairs of Alice and Bob (first and last
  qubit) on the Bell state (|00> + |11>)/sqrt(2)."""
  proj = bell_proj()
  size = 2**(2*(n+2))
  size_inside = 2**(2*(n+1))
  new_state = state.copy()
  new_state = new_state.reshape(2, size_inside, 2)
  new_state = new_state.transpose([0, 2, 1])
  new_state = new_state.reshape(size)
  op = np.kron(proj, np.eye(size_inside))
  new_state = op @ new_state
  new_state = new_state.reshape(2, 2, size_inside)
  new_state = new_state.transpose([0, 2, 1])
  new_state = new_state.reshape(size)
  return new_state

def find_psi_after_swap(n, H, beta):
  psi = prepare_init_state(n, H, beta)
  psi = swap(psi)
  return psi

def find_probs(n, H, psi_swap, t):
  """Find probability of successful postselection and entanglement swap, for
  given Hamiltonian H, the state after the swap, and the evolution time t."""
  psi = psi_swap.copy()
  psi = apply_unitaries(psi, n, H, t)
  psi = apply_proj(psi, n)
  prob_postselection = np.linalg.norm(psi)**2
  psi = bell_meas(psi, n)
  prob_swap = (np.linalg.norm(psi)**2) / prob_postselection
  return prob_postselection, prob_swap

def find_prediction(n, H, beta):
  Z = partition_function(H, beta)
  Z_half = partition_function(H, beta/2)
  N = 2**n
  F = (Z_half**2)/(Z*N)
  num = 1 + 3*F - 2/(N**2)
  den = 4 + 3*F - 4/(N**2)
  return num/den

def partial_trace_1_qubit(rho, b):
  """Trace away qubit b from state rho"""
  n = int(np.log2(len(rho)))
  rho_new = rho.copy()
  if b == 0:
    new_shape = 2*[2, 2**(n-1)]
    rho_new = rho_new.reshape(*new_shape)
    rho_new = np.einsum('ijik', rho_new)
  elif b == n-1:
    new_shape = 2*[2**(n-1), 2]
    rho_new = rho_new.reshape(*new_shape)
    rho_new = np.einsum('ijkj', rho_new)
  else:
    new_shape = 2*[2**(b), 2, 2**(n-b-1)]
    rho_new = rho_new.reshape(*new_shape)
    rho_new = np.einsum('ijkljm', rho_new)
  rho_new = rho_new.reshape(2**(n-1), 2**(n-1))
  return rho_new

def partial_trace(rho, B):
  """Trace away qubits listed in B from n-qubit state psi"""
  B_sorted = B.copy()
  B_sorted.sort()
  rho_new = rho.copy()
  for i in range(len(B_sorted)):
    b = B_sorted[i]
    rho_new = partial_trace_1_qubit(rho_new, b)
    B_sorted = [b-1 for b in B_sorted]
  return rho_new

def experiment(n, H, beta, ts):
  probs_swap = []
  psi_swap = find_psi_after_swap(n, H, beta)
  for t in ts:
    prob_swap = find_probs(n, H, psi_swap, t)[1]
    probs_swap.append(prob_swap)
  return probs_swap

"""### Some checks"""

def check_tfd_for_beta_0():
    """# check tfd for beta = 0"""

    n = 4
    beta = 0
    H = get_H(n)
    tfd = prepare_tfd(n, H, beta)
    bell = prepare_bell()
    tfd_correct  = bell
    for i in range(n-1):
      tfd_correct = np.kron(tfd_correct , bell)
    tfd_correct  = tfd_correct.reshape((2*n)*[2])
    if n%2 == 0:
      transposition = [i if i%2==0 else 2*n-i for i in range(n)] + [n+i if i%2==0 else n-i for i in range(n)]
    else:
      transposition = [i if i%2==0 else 2*n-i for i in range(n)] + [n] + [n+1+i if i%2==0 else n-1-i for i in range(n-1)]
    tfd_correct  = tfd_correct.transpose(transposition)
    tfd_correct  = tfd_correct.reshape(2**(2*n))
    print(np.abs(tfd-tfd_correct).sum())

    psi = find_psi_after_swap(n, H, beta)
    rho = rho = np.outer(psi, psi)
    rho_A =partial_trace(rho, [1, 2*(n+1)])
    print(np.trace(rho_A@rho_A))

    m = n-1
    psi  = bell
    for i in range(m-1):
      psi = np.kron(psi , bell)
    psi  = psi.reshape((2*m)*[2])
    if m%2 == 0:
      transposition = [i if i%2==0 else 2*m-i for i in range(m)] + [m+i if i%2==0 else m-i for i in range(m)]
    else:
      transposition = [i if i%2==0 else 2*m-i for i in range(m)] + [m] + [m+1+i if i%2==0 else m-1-i for i in range(m-1)]
    psi  = psi.transpose(transposition)
    psi  = psi.reshape(2**(2*m))
    psi = np.kron(bell, psi)
    psi = np.kron(psi, bell)
    print(np.abs(rho_A - np.outer(psi, psi)).sum())

def run_experiment(n, beta):
    """Runs the above --
    @param n: The number of pairs in the TFD state.
    @param beta: 1/T
    """
    print(f'Running experiment with n={n}, beta={beta}')
    H = get_H(n)
    tmax = 2
    ts = np.linspace(0, tmax, 100)
    probs_swap = experiment(n, H, beta, ts)
    pred = find_prediction(n, H, beta)
    plt.plot(ts, np.array(probs_swap))
    plt.hlines(pred, 0, tmax)
    plt.show()

# n=4, beta=0
run_experiment(n=4, beta=0)

"""### Experiment with $\beta \neq 0$"""
def run_experiment_2(n, beta):
    print(f'Running experiment_2 with n={n}, beta={beta}')
    H = get_H(n)
    beta = 1
    tmax = 2*beta
    ts = np.linspace(0, tmax, 100)
    probs_swap = experiment(n, H, beta, ts)
    pred = find_prediction(n, H, beta)
    plt.plot(ts, np.array(probs_swap))
    plt.hlines(pred, 0, tmax)
    plt.show()

# n=4, beta=1
run_experiment_2(4, 1)

# n=4, beta=10
run_experiment(4, 10)

"""## Experiments with $n=5$"""

run_experiment_2(5, 1)
